package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.49

import (
	"backend/internal/graphql/generated"
	"backend/internal/graphql/models"
	"context"
	"errors"
	"fmt"
	"math/rand"
)

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, username string, password string, email string, topics []string) (string, error) {
	// Register the user using CognitoAuthService
	fmt.Print("Registering user")
	fmt.Printf(r.AuthService.ClientId)
	cognitoResponse, err := r.AuthService.SignUp(email, username, password)
	if err != nil {
		return "", err
	}

	// Extract the username from the Cognito response
	registeredUsername := cognitoResponse.UserSub

	// Create a new user with the registered username
	user := models.User{
		Name:                    *registeredUsername,
		Email:                   email,
		Topics:                  topics,
		DailyChallengeAvailable: true,
	}

	// Insert the user into the repository
	user, err = r.UserRepo.UpsertUser(user)
	if err != nil {
		return "", err
	}

	return *registeredUsername, nil
}

// ConfirmEmail is the resolver for the confirmEmail field.
func (r *mutationResolver) ConfirmEmail(ctx context.Context, email string, token string) (bool, error) {
	_, err := r.AuthService.ConfirmSignUp(email, token)
	if err != nil {
		return false, err
	}

	return true, nil
}

// DailyChallenge is the resolver for the dailyChallenge field.
func (r *mutationResolver) DailyChallenge(ctx context.Context, username string, question string, answer string) (*models.ChallengeResponse, error) {
	response, err := r.ProblemRepo.SubmitChallengeResponse(username, question, answer)
	if err != nil {
		return nil, err
	}

	// Update the user's daily challenge availability
	user, err := r.UserRepo.GetUserByName(username)
	if err != nil {
		return nil, err
	}

	user.DailyChallengeAvailable = false
	_, err = r.UserRepo.UpsertUser(*user)
	if err != nil {
		return nil, err
	}

	return &response, nil
}

// AddTopics is the resolver for the addTopics field.
func (r *mutationResolver) AddTopics(ctx context.Context, names []string) ([]*models.Topic, error) {
	var topics []*models.Topic
	for _, name := range names {
		topics = append(topics, &models.Topic{Name: name})
	}
	if err := r.TopicRepo.Insert(ctx, topics); err != nil {
		return nil, err
	}
	return topics, nil
}

// UpsertCourse is the resolver for the upsertCourse field.
func (r *mutationResolver) UpsertCourse(ctx context.Context, input models.CourseInput) (*models.Course, error) {
	panic(fmt.Errorf("not implemented: UpsertCourse - upsertCourse"))
}

// UpsertRoadmap is the resolver for the upsertRoadmap field.
func (r *mutationResolver) UpsertRoadmap(ctx context.Context, input models.RoadmapInput) (*models.Roadmap, error) {
	panic(fmt.Errorf("not implemented: UpsertRoadmap - upsertRoadmap"))
}

// Login is the resolver for the login field.
func (r *queryResolver) Login(ctx context.Context, username string, password string) (*models.AuthPayload, error) {
	// TODO: Change parameter to email
	// Authenticate the user using CognitoAuthService
	cognitoResponse, err := r.AuthService.Login(username, password)
	if err != nil {
		return nil, errors.New("invalid email or password")
	}

	// Extract the token from the Cognito response
	tokenString := cognitoResponse.AuthenticationResult.IdToken

	return &models.AuthPayload{
		Token: *tokenString,
	}, nil
}

// GetUsers is the resolver for the getUsers field.
func (r *queryResolver) GetUsers(ctx context.Context) ([]*models.User, error) {
	users := r.UserRepo.GetUsers()
	return users, nil
}

// GetUserByName is the resolver for the getUserByName field.
func (r *queryResolver) GetUserByName(ctx context.Context, name string) (*models.User, error) {
	user, err := r.UserRepo.GetUserByName(name)
	if err != nil {
		return nil, err
	}
	return user, nil
}

// ResendConfirmationEmail is the resolver for the resendConfirmationEmail field.
func (r *queryResolver) ResendConfirmationEmail(ctx context.Context, email string) (bool, error) {
	_, err := r.AuthService.ResendConfirmationCode(email)
	if err != nil {
		return false, err
	} else {
		return true, nil
	}
}

// DailyChallenge is the resolver for the dailyChallenge field.
func (r *queryResolver) DailyChallenge(ctx context.Context, userID string) (*models.Problem, error) {
	// Get the user with userID
	user, err := r.UserRepo.GetUserByName(userID)
	if err != nil {
		return nil, err
	}

	//Get a random topic from the user
	i := rand.Int() % len(user.Topics)

	problem, err := r.ProblemRepo.GetDailyChallenge(user.Topics[i])
	if err != nil {
		return nil, err
	}
	return problem, nil
}

// GetAllTopics is the resolver for the getAllTopics field.
func (r *queryResolver) GetAllTopics(ctx context.Context) ([]*models.Topic, error) {
	return r.TopicRepo.GetAllTopics(ctx)
}

// GetQuizes is the resolver for the getQuizes field.
func (r *queryResolver) GetQuizes(ctx context.Context) ([]*models.Quiz, error) {
	panic(fmt.Errorf("not implemented: GetQuizes - getQuizes"))
}

// GetLessons is the resolver for the getLessons field.
func (r *queryResolver) GetLessons(ctx context.Context) ([]*models.Lesson, error) {
	panic(fmt.Errorf("not implemented: GetLessons - getLessons"))
}

// GetCourses is the resolver for the getCourses field.
func (r *queryResolver) GetCourses(ctx context.Context) ([]*models.Course, error) {
	panic(fmt.Errorf("not implemented: GetCourses - getCourses"))
}

// GetRoadmaps is the resolver for the getRoadmaps field.
func (r *queryResolver) GetRoadmaps(ctx context.Context) ([]*models.Roadmap, error) {
	panic(fmt.Errorf("not implemented: GetRoadmaps - getRoadmaps"))
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
