package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.49

import (
	"backend/internal/graphql/generated"
	"backend/internal/graphql/models"
	"context"
	"errors"
	"fmt"
	"time"

	jwt "github.com/dgrijalva/jwt-go"
)

// UpsertUser is the resolver for the upsertUser field.
func (r *mutationResolver) UpsertUser(ctx context.Context, input models.UserInput) (*models.User, error) {
	user := models.User{
		ID:    input.ID,
		Name:  input.Name,
		Email: input.Email,
	}
	upsertedUser, err := r.UserRepo.UpsertUser(user)
	if err != nil {
		return nil, err
	}
	return &upsertedUser, nil
}

// UpsertProblem is the resolver for the upsertProblem field.
func (r *mutationResolver) UpsertProblem(ctx context.Context, input models.ProblemInput) (*models.Problem, error) {
	problem := models.Problem{
		Question:   input.Question,
		Categories: input.Categories,
		Type:       input.Type,
	}
	upsertedProblem := r.ProblemRepo.UpsertProblem(problem)
	return &upsertedProblem, nil
}

// DailyChallenge is the resolver for the dailyChallenge field.
func (r *mutationResolver) DailyChallenge(ctx context.Context, username string, question string, answer string) (*models.ChallengeResponse, error) {
	response, err := r.ProblemRepo.SubmitChallengeResponse(username, question, answer)
	if err != nil {
		return nil, err
	}

	// Update the user's daily challenge availability
	user, err := r.UserRepo.GetUserByName(username)
	if err != nil {
		return nil, err
	}

	user.DailyChallengeAvailable = false
	_, err = r.UserRepo.UpsertUser(*user)
	if err != nil {
		return nil, err
	}

	return &response, nil
}

// Register is the resolver for the register field.
func (r *mutationResolver) Register(ctx context.Context, username string, password string, email string, topics []string) (*models.AuthPayload, error) {
	// Register the user using CognitoAuthService
	fmt.Print("Registering user")
	fmt.Printf(r.AuthService.ClientId)
	cognitoResponse, err := r.AuthService.SignUp(email, username, password)
	if err != nil {
		return nil, err
	}

	// Extract the username from the Cognito response
	registeredUsername := cognitoResponse.UserSub

	// Create a new user with the registered username
	user := models.User{
		Name:                    *registeredUsername,
		Email:                   email,
		Topics:                  topics,
		DailyChallengeAvailable: true,
	}

	// Insert the user into the repository
	user, err = r.UserRepo.UpsertUser(user)
	if err != nil {
		return nil, err
	}

	// Generate a JWT token for the user
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
		"userId": user.ID,
		"exp":    time.Now().Add(time.Hour * 72).Unix(),
	})

	tokenString, err := token.SignedString(jwtSecret)
	if err != nil {
		return nil, err
	}

	return &models.AuthPayload{
		Token: tokenString,
		User:  &user,
	}, nil
}

// AddTopics is the resolver for the addTopics field.
func (r *mutationResolver) AddTopics(ctx context.Context, names []string) ([]*models.Topic, error) {
	var topics []*models.Topic
	for _, name := range names {
		topics = append(topics, &models.Topic{Name: name})
	}
	if err := r.TopicRepo.Insert(ctx, topics); err != nil {
		return nil, err
	}
	return topics, nil
}

// ConfirmEmail is the resolver for the confirmEmail field.
func (r *mutationResolver) ConfirmEmail(ctx context.Context, email string, token string) (bool, error) {
	_, err := r.AuthService.ConfirmSignUp(email, token)
	if err != nil {
		return false, err
	}

	return true, nil
}

// UpsertCourse is the resolver for the upsertCourse field.
func (r *mutationResolver) UpsertCourse(ctx context.Context, input models.CourseInput) (*models.Course, error) {
	panic(fmt.Errorf("not implemented: UpsertCourse - upsertCourse"))
}

// UpsertRoadmap is the resolver for the upsertRoadmap field.
func (r *mutationResolver) UpsertRoadmap(ctx context.Context, input models.RoadmapInput) (*models.Roadmap, error) {
	panic(fmt.Errorf("not implemented: UpsertRoadmap - upsertRoadmap"))
}

// GetUsers is the resolver for the getUsers field.
func (r *queryResolver) GetUsers(ctx context.Context) ([]*models.User, error) {
	users := r.UserRepo.GetUsers()
	return users, nil
}

// GetUserByName is the resolver for the getUserByName field.
func (r *queryResolver) GetUserByName(ctx context.Context, name string) (*models.User, error) {
	user, err := r.UserRepo.GetUserByName(name)
	if err != nil {
		return nil, err
	}
	return user, nil
}

// GetProblems is the resolver for the getProblems field.
func (r *queryResolver) GetProblems(ctx context.Context) ([]*models.Problem, error) {
	problems := r.ProblemRepo.GetProblems()
	return problems, nil
}

// GetUser is the resolver for the getUser field.
func (r *queryResolver) GetUser(ctx context.Context, id string) (*models.User, error) {
	return r.UserRepo.GetUserByID(id)
}

// DailyChallenge is the resolver for the dailyChallenge field.
func (r *queryResolver) DailyChallenge(ctx context.Context, category string) (*models.Problem, error) {
	problem, err := r.ProblemRepo.GetDailyChallenge(category)
	if err != nil {
		return nil, err
	}
	return problem, nil
}

// Login is the resolver for the login field.
func (r *queryResolver) Login(ctx context.Context, username string, password string) (*models.AuthPayload, error) {
	// TODO: Change parameter to email
	// Authenticate the user using CognitoAuthService
	cognitoResponse, err := r.AuthService.Login(username, password)
	if err != nil {
		return nil, errors.New("invalid email or password")
	}

	// Extract the token from the Cognito response
	tokenString := cognitoResponse.AuthenticationResult.IdToken

	return &models.AuthPayload{
		Token: *tokenString,
		User:  nil,
	}, nil
}

// GetAllTopics is the resolver for the getAllTopics field.
func (r *queryResolver) GetAllTopics(ctx context.Context) ([]*models.Topic, error) {
	return r.TopicRepo.GetAllTopics(ctx)
}

// ResendConfirmationEmail is the resolver for the resendConfirmationEmail field.
func (r *queryResolver) ResendConfirmationEmail(ctx context.Context, email string) (bool, error) {
	_, err := r.AuthService.ResendConfirmationCode(email)
	if err != nil {
		return false, err
	} else {
		return true, nil
	}
}

// GetQuizes is the resolver for the getQuizes field.
func (r *queryResolver) GetQuizes(ctx context.Context) ([]*models.Quiz, error) {
	panic(fmt.Errorf("not implemented: GetQuizes - getQuizes"))
}

// GetLessons is the resolver for the getLessons field.
func (r *queryResolver) GetLessons(ctx context.Context) ([]*models.Lesson, error) {
	panic(fmt.Errorf("not implemented: GetLessons - getLessons"))
}

// GetCourses is the resolver for the getCourses field.
func (r *queryResolver) GetCourses(ctx context.Context) ([]*models.Course, error) {
	panic(fmt.Errorf("not implemented: GetCourses - getCourses"))
}

// GetRoadmaps is the resolver for the getRoadmaps field.
func (r *queryResolver) GetRoadmaps(ctx context.Context) ([]*models.Roadmap, error) {
	panic(fmt.Errorf("not implemented: GetRoadmaps - getRoadmaps"))
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &mutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
var jwtSecret = []byte("your_secret_key")
